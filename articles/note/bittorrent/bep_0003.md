# [The BitTorrent Protocol Specification](http://bittorrent.org/beps/bep_0003.html) (翻译)

BitTorrent是一种用于分发文件的协议。它通过URL标识内容，旨在与Web无缝集成。 它优于普通HTTP协议，当同一文件的多次下载同时发生时，下载程序会相互上传，从而使文件源可以支持大量下载，对服务器的负载压力不是很大。

### 一个BT正常工作需要包含以下部分：
- 一个Web服务器
- 一个静态元信息文件（'metainfo' file）
- 一个 BT 跟踪器（tracker）
- 一个初始下载器（'original' downloader）
- 用户终端浏览器
- 用户终端下载器

1个BT文件有多个用户终端。

### 启动 BT 服务，有以下步骤：
- 1.启动跟踪器（tracker）。
- 2.启动Web服务器，如 apache。
- 3.在Web服务器中用 `application/x-bittorrent` 的 mimetype 关联 .torrent 文件。
- 4.根据完整文件（供他人下载的文件）和跟踪器的URL生成元信息（.torrent）文件。
- 5.将元信息文件（.torrent）发布到其他网站上。
- 6.启动一个已经拥有完整文件（'origin'）的下载程序。

### B编码
- 字符串类型：以十进制表示的长度为前缀，后跟冒号和字符串。 例如 "4:spam" 对应字符串 "spam"。
- 整数类型：'i' 字符后跟十进制数字，再跟 'e' 结束。例如 "i3e" 对应数字 3，"i-3e" 对应数字 -3。整数类型没有大小限制。"i-0e" 是无效的。所有以 0 为开头的编码形式，如 "i03e"，是无效的。除了 "i0e"，当然它对应 0。
- 列表类型：'l' 后跟列表元素，以 'e' 结尾。例如 "l4:spam4:eggse" 对应列表 "['spam', 'eggs']"。
- 字典类型：'d' 后跟交替的键与值的列表，以 'e' 结尾。例如 "d3:cow3:moo4:spam4:eggse" 对应 "{'cow': 'moo', 'spam': 'eggs'}"，"d4:spaml1:a1:bee" 对应 "{'spam': ['a', 'b']}"。键必须为排好序的字符类型（以原生字符串排序，而不是字母序）。

### 源信息文件（metainfo files）
源信息文件（即 .torrent 文件）其内容需要被编码成字典类型，包含下面的建：

- `announce`：跟踪器的 url。
- `info`：以下面将要描述的键构成的字典。

.torrent 文件内的文本内容都必须用 UTF-8 进行编码。

#### info 字典

`name` 的值是 UTF-8 编码的字符串，该字符串是保存文件（或目录）时的建议名称。这纯粹是建议性的。

`piece length` 的值是文件被拆分成每个部分中的字节数。 出于传输的目的，文件被分成固定大小的片段，除了可能被截断的最后一个片段之外，它们的长度都相同。`piece length` 几乎总是2的幂，最常见的是 2^18=256K（版本3.2之前的BitTorrent默认使用 2^20=1M）。

`pieces` 的值是长度为20的倍数的字符串。它被细分为长度为20的字符串，每个字符串都是相应索引处的片段的SHA1哈希值。

还有一个`length`或`files`，但不是两者都兼有。 如果存在`length`，则下载表示单个文件，否则它表示进入目录结构的一组文件。

在单个文件的情况下，`length` 表示文件的长度（以字节为单位）。

对于另一个键 `files`，在多文件情况下，其值被看作是按文件列表顺序相连的文件集。即文件列表是包含以下键的字典列表：

- `length`: 文件长度，字节单位。
- `path`: 与子目录名对应的UTF-8编码字符串列表，其中最后一个是实际文件名（零长度列表是错误情况）。

在单个文件的情况下，name 键是文件的名称，在多文件的情况下，它是目录的名称。

### 跟踪器（tracker）

跟踪器GET请求具有以下键：

- `info_hash`: 源信息文件的 `info` 值进行 sha-1 哈希。这个值几乎肯定必须被转义。注意，这个 `info` 值是元信息文件的子字符串。 info-hash 必须是.torrent文件中找到的编码内容的散列，这与对元信息文件进行解码相同，提取`info`字典并对其进行编码，当且仅当bdecoder完全验证了输入内容（例如键顺序，没有以0为开头的整数类型）。这意味着客户端必须拒绝无效的元信息文件或直接提取子字符串。 它们不得对无效数据执行解码编码。

- `peer_id`: 20 字节的字符串，用来作为下载器的 id。每个下载器在开始一个新的下载时随机生成自己的 id。

- `ip`: 可选参数，给出该对端所在的IP（或dns名称）。通常用于源下载程序（origin 文件所在的下载程序），如果它与跟踪器在同一台机器上。

- `port`: 对端（peer）监听的端口号。通常下载程序会尝试监听 6881 端口，如果被占用则依次监听 6882，6883，到 6889 还被占用的话，放弃监听。

- `uploaded`: 目前为止已经上传的总量，用十进制ascii编码。

- `downloaded`: 目前为止已经下载的总量，用十进制ascii编码。

- `left`: 这个对端（peer）仍需要下载的字节数，用十进制ascii编码。请注意，这不能通过下载和文件长度来计算，因为它可能是一个恢复（resume）状态的下载，并且有些下载的数据可能无法通过完整性检查而不得不重新下载。

- `event`: 可选参数，对应 started，completed，stopped （或者 empty，指不存在）。如果不存在，这是定期完成的通知（announcements）之一。started 通知在第一次下载开始时发送，completed 通知在下载完成时发送。如果文件在下载开始时已经完成下载，则不发送 completed 通知。下载程序在停止下载时使用 stopped 发送通知。

跟踪器响应是编码过的字典列表。 如果跟踪器响应中包含 `failure reason` 键，则该值显示了查询失败的原因，并且不需要其他键。 否则，它必须有两个键：`interval`，它指下载器在再请求需要等待的秒数。 `peers` 指对端对应的字典列表，每个字典包含`peer id`，`ip`和`port`，它们分别指对端自选ID，IP地址或dns名称，以及端口号。请注意，如果携带了 `event` 参数或需要更多对端时，下载程序可能会在非计划时间重新请求（即不做等待，立马再请求）。

通常，跟踪器都会返回一个压缩过的对端列表（peer list），见 [BEP23](bep_0023.md)

如果您想对元信息文件或跟踪器查询进行任何扩展，请与Bram Cohen协调以确保所有扩展都能兼容完成。

通常，通知的请求基于 [UDP tracker protocol](bep_0015.md)。

### 对端协议 （peer protocol）

BitTorrent 的对端协议基于 TCP 或 [uTP](bep_0029.md)。

对端连接是对称的。在两个方向上发送的消息看起来相同，数据可以在任一方向上流动。

对端协议通过索引(从0开始)引用文件的片段，正如元信息文件中描述的那样。 当一端完成下载一个片段并检查该哈希值是否匹配时，它对所有对端宣布它拥有该片段。

连接在任一端包含两个状态位："阻塞"(choked)或不阻塞，感兴趣(interested)与否。"阻塞"(Choking)是一种通知，在发生解除"阻塞"之前不会发送任何数据。 "阻塞"背后的原理和常见技术将在本文后面解释。

只要一方感兴趣而另一方没有"阻塞"，就会进行数据传输。兴趣状态(interest state)必须始终保持最新状态——当一个下载器没有请求对端解除"阻塞"的情况，则必须表现为缺乏兴趣，尽管被"阻塞"。 正确实现这一点有些困难，但是下载器可以知道哪些对端会在"解阻塞"的情况下立即开始下载。

客户端的连接以"被阻塞"和"不感兴趣"开始。

在传输数据时，下载程序应让多个请求分组排队以获得良好的TCP性能（这称为“流水线”。）另一方面，无法立即写入TCP缓冲区的请求 应该在内存中排队而不是保存在应用程序级网络缓冲区中(当发生"阻塞"时它们都会被丢弃)。

对端协议包括握手步骤，后跟连续不断的以长度为前缀消息流。握手以字符 19（十进制）开头，后跟字符串'BitTorrent protocol'。 前导字符是长度前缀，放在那里，希望其他新协议可以做同样的事情，从而可以在很小的方面彼此区分。

所有在协议中发送的后来的整数都被编码为四字节 Big-endian 形式。

在固定头之后有八个保留字节，在所有当前实现中都是0。如果您希望使用这些字节扩展协议，请与Bram Cohen协调以确保所有扩展都兼容。

接下来是来自元信息文件的信息值的B编码形式的20字节sha1哈希。 （这与向跟踪器宣布为 info_hash 的值相同，只是在这里它是源头的而不是引用）。 如果双方都没有发送相同的值，则会切断连接。 一个可能的例外是，如果下载者想要通过单个端口进行多次下载，他们可能会等待传入连接首先提供下载哈希，并且如果它在列表中则响应相同的连接。

在下载散列之后出现20字节的对端ID(peer id)，该对端ID在跟踪器请求中报告并包含在跟踪器响应中的对端列表中。 如果接收方的对端ID与发起方期望的对端ID不匹配，则会切断连接。

这就是握手，接下来是长度前缀和消息的交替流。长度为零的消息是keepalive，并被忽略。 Keepalive通常每两分钟发送一次，但请注意，在数据是可预期的，可以更快地判断是否超时。


### 对端消息（peer messages）

所有非 keepalive 消息开始于一个字节，该字节代表当前消息的类型：

- 0: choke
- 1: unchoke
- 2: interested
- 3: not interested
- 4: have
- 5: bitfield
- 6: request
- 7: piece
- 8: cancel

'choke'、'unchode'、'interested'、'not interested' 无有效负载（payload，可以理解为消息体）

'bitfield'只作为第一条消息发送。 它的有效负载是一个位域，下载器发送的每个索引都设置为1，其余的设置为零。 没有任何内容的下载程序可能会跳过"位域"消息。位域的第一个字节分别对应于从高位到低位的索引0-7。 下一个8-15等。末尾的备用位设置为零。

'have'消息的有效负载是一个数字，指该下载器刚刚完成并检查了散列的索引。

'request'消息包含索引，开头和长度。最后两个是字节偏移。长度通常是2的幂，除非它在文件末尾被截断。 所有当前实现都使用2^14（16 kiB），并且请求大于该值时关闭连接。

'cancel'消息与请求消息具有相同的有效负载。它们通常仅在下载结束时发送，称为“结束游戏模式”。 当下载几乎完成时，最后几个片段的趋势是从单个调制解调器线路下载，需要很长时间。 为了确保最后几个片段快速进入，一旦给定下载器的所有片段的请求当前尚未处理，它会向所有正在下载的人发送所有请求。为了防止这种情况变得非常低效，每当一个片段到达时，它就会向其他人发送取消。

'piece'消息包含索引，开头和片段。请注意，它们隐式与请求消息相关联。 如果快速连续发送"阻塞"和"取消"消息和/或传输速度非常慢，则可能会出现不可预知的片段。

下载程序通常以随机顺序下载片段，这样做可以很好地防止它们拥有任何同类文件的严格子集或超集。

"阻塞"有几个原因。当一次发送多个连接时，TCP拥塞控制表现很差。 此外，"阻塞"让每个对端使用 tit-for-tat-ish 算法来确保他们获得一致的下载速率。

下面描述的阻塞算法是当前部署的算法。 非常重要的是，所有新算法在完全由他们自己组成的网络中以及在主要由这个组成的网络中都能很好地工作。

一个好的阻塞算法应该满足几个标准。它应该限制同时上传的数量以获得良好的TCP性能。 它应该避免阻塞和解阻塞，称为“颤动”（fibrillation）。它应该回应让它下载的对端。 最后，它应该偶尔尝试使用未使用的连接，以确定它们是否可能比当前使用的更好，称为乐观解阻塞（optimistic unchoking）。

目前使用的阻塞算法通过每10秒钟改变被阻塞对端来避免颤动。 它通过对其具有最佳下载速率并且感兴趣的四个对端解阻塞来实现往复和上传数量的限制。 拥有更高上传率但不感兴趣的对端会被解阻塞，如果他们感兴趣，最糟糕的上传者会被阻塞。 如果下载程序具有完整文件，则使用其上载速率而不是其下载速率来决定谁会被解阻塞。

对于乐观解阻塞，在任何时候都有一个单独的对端，无论其上传速率如何都是解阻塞状态（如果感兴趣的话，它将被视为四个允许的下载者中的一个。）哪个对端乐观地解阻塞每30秒轮换一次。 为了给他们一个完整的片段上传机会，新的连接的开始乐观解阻塞有三次机会，其过程与轮换中的其他任何地方一样。

### 资料
- [BitTorrent论文](http://bittorrent.org/bittorrentecon.pdf)讲述了客户端应该实现的一些请求和阻塞算法以获得最佳性能

- 在开发新实现时，Wireshark协议分析器及其[bittorrent解析器](https://wiki.wireshark.org/BitTorrent)可用于调试和与现有实现进行比较。

### 版权
本文档已置于公共领域。